<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Young&#39;s Blog</title>
  
  <subtitle>曾梦想仗剑走天涯 不料却湿身撸代码</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-17T08:29:45.376Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>阿浪</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hbase实现分页查询</title>
    <link href="http://yoursite.com/2018/07/06/Hbase%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/"/>
    <id>http://yoursite.com/2018/07/06/Hbase实现分页查询/</id>
    <published>2018-07-06T01:32:01.000Z</published>
    <updated>2018-08-17T08:29:45.376Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>写在前面</p></blockquote><p>1.hbase查询批量数据是通过scan扫描表的，一般都是按条件查询，可以通过过滤器Filter锁定满足条件的数据。</p><p>2.分页查询需要知道数据总数，而对于hbase这比较麻烦，不能像传统数据库一样直接count(*),暂时通过循环遍历去获得总数。<br><a id="more"></a><br>3.分页查询时前端传过来的参数：</p><ul><li><p>当前需要查询第几页的数据: pageIndex</p></li><li><p>每次查询的数据个数：pageSize (一般固定)</p></li></ul><p>4.分页查询需要获得数据：</p><ul><li><p>数据总数</p></li><li><p>当前页面对应的数据</p></li></ul><blockquote><p>具体思路</p></blockquote><p>hbase通过scan设置startRow,以及PageFilter设置需要查询的个数，即可完成分页查询。</p><blockquote><p>步骤：</p></blockquote><p>1.获取总数</p><p>下面案例使用了前缀过滤器PrefixFilter，其实能定位到startRow,和stopRow更好，再结合FirstKeyOnlyFilter，过滤第一列的值，提高查询效率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public static int countBy(String rowKey,String tableName)&#123;</div><div class="line">Table table=null;</div><div class="line">try &#123;</div><div class="line">table = HbaseUtil.getConnection().getTable(TableName.valueOf(tableName));//获得表</div><div class="line">&#125; catch (IOException e1) &#123;</div><div class="line">e1.printStackTrace();</div><div class="line">&#125;</div><div class="line">    int cnt=0;</div><div class="line">PrefixFilter prefix = new PrefixFilter(Bytes.toBytes(rowKey));//前缀过滤器</div><div class="line">    Scan scan = new Scan();  //扫描器</div><div class="line">//    scan.setStartRow(Bytes.toBytes(startRow));</div><div class="line">//    scan.setStopRow(Bytes.toBytes(stopRow));</div><div class="line">scan.setCaching(500);</div><div class="line">scan.setCacheBlocks(false);</div><div class="line">FirstKeyOnlyFilter first = new FirstKeyOnlyFilter();//过滤第一列的值,提高查询效率</div><div class="line">FilterList filter = new FilterList(FilterList.Operator.MUST_PASS_ALL);//组合过滤器</div><div class="line">filter.addFilter(prefix);</div><div class="line">filter.addFilter(first);</div><div class="line">scan.setFilter(filter); </div><div class="line">ResultScanner rs = null;</div><div class="line">try &#123;</div><div class="line">rs = table.getScanner(scan);</div><div class="line">for (org.apache.hadoop.hbase.client.Result r : rs) &#123;</div><div class="line">cnt++ ;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line"></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line">return cnt;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><hr><p>2.每次查询待重新定位starRow，就是把前端传送过来的    pageIndex转换成startRow。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">private static String GetCurrentPageStartRow(String rowKey,String tableName,int pageIndex, int pageSize) throws Exception &#123;</div><div class="line"></div><div class="line">// 如果 传送过来的额  pageIndex 不合法。 默认返回 第一页数据</div><div class="line">if (pageIndex &lt;=1) &#123;</div><div class="line">return null;</div><div class="line">&#125;else &#123;</div><div class="line">//从第二页开始的所有数据。</div><div class="line">String startRow = null;</div><div class="line"></div><div class="line">for (int i = 1; i &lt; pageIndex; i++) &#123;</div><div class="line">//第几次循环，就是获取第几页的数据</div><div class="line">ResultScanner pageData = getPageData(rowKey,tableName,startRow, pageSize);</div><div class="line">//获取当前这一页的最后rowkey</div><div class="line">Iterator&lt;Result&gt; iterator = pageData.iterator();</div><div class="line">Result result = null;</div><div class="line">while (iterator.hasNext()) &#123;</div><div class="line"> </div><div class="line">result = iterator.next();</div><div class="line">&#125;</div><div class="line">//让最后一个rowkey往后挪动一点位置，但是又不会是下一页的startRow</div><div class="line">String endRowStr = new String(result.getRow());</div><div class="line">byte[] add = Bytes.add(endRowStr.getBytes(), new byte[]&#123; 0x00&#125;);</div><div class="line"></div><div class="line">String nextPageStartRowstr = Bytes.toString(add);</div><div class="line"></div><div class="line">startRow = nextPageStartRowstr;</div><div class="line">&#125;</div><div class="line">return startRow;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">private static ResultScanner getPageData(String rowKey,String tableName,String startRow, int pageSize) throws Exception &#123;</div><div class="line"></div><div class="line"></div><div class="line">Table table =null;</div><div class="line">//获得表</div><div class="line">try &#123;</div><div class="line">table = getConnection().getTable(TableName.valueOf(tableName));</div><div class="line">&#125; catch (IOException e1) &#123;</div><div class="line">logger.warn(&quot;表不存在!&quot;);</div><div class="line">e1.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line">Scan scan = new Scan();</div><div class="line">    scan.setCaching(20);</div><div class="line">        scan.setCacheBlocks(false);</div><div class="line"></div><div class="line">//设置起始行键搞定</div><div class="line">//如果是第一页数据，所以scan.setStartRow这句代码根本就没有任何意义，不用设置即可</div><div class="line">if (!StringUtils.isBlank(startRow)) &#123;</div><div class="line"></div><div class="line">//如果用户不传入startRow，或者传入一个非法的startRow，还是按照规则返回第一页</div><div class="line">scan.setStartRow(startRow.getBytes());</div><div class="line">&#125;</div><div class="line">PrefixFilter prefix = new PrefixFilter(Bytes.toBytes(rowKey));//前缀过滤器</div><div class="line">FilterList filter1 = new FilterList(FilterList.Operator.MUST_PASS_ALL);</div><div class="line"></div><div class="line">//设置总数据条件</div><div class="line">Filter pageFilter = new PageFilter(pageSize);</div><div class="line">filter1.addFilter(prefix);</div><div class="line">filter1.addFilter(pageFilter);</div><div class="line">scan.setFilter(filter1);</div><div class="line"></div><div class="line">ResultScanner scanner = table.getScanner(scan);</div><div class="line"></div><div class="line"></div><div class="line">return scanner;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><p>3.需要获得每次查询的个数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Table table=getTable(tableName);</div><div class="line">int counts =countBy(rowKey,table);</div><div class="line">int size=0;</div><div class="line">if(counts&gt;=pageIndex*pageSize)&#123;</div><div class="line">size=pageSize;</div><div class="line">&#125;</div><div class="line">if(counts&lt;pageIndex*pageSize)&#123;</div><div class="line">size=counts%pageSize;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><p>4.通过scan设置startRow和pageFilter(size)查询结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;Map&lt;String,String&gt;&gt; list=new ArrayList&lt;Map&lt;String,String&gt;&gt;();</div><div class="line">//startRow和size由上面方法得出</div><div class="line">ResultScanner scanner=getPageData(rowKey,tableName,startRow,size);</div><div class="line">list=scanTable(scanner, table);</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">private static ResultScanner getPageData(String rowKey,String tableName,String startRow, int size) throws Exception &#123;</div><div class="line"></div><div class="line"></div><div class="line">Table table =null;</div><div class="line">//获得表</div><div class="line">try &#123;</div><div class="line">table = getConnection().getTable(TableName.valueOf(tableName));</div><div class="line">&#125; catch (IOException e1) &#123;</div><div class="line">logger.warn(&quot;表不存在!&quot;);</div><div class="line">e1.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line">Scan scan = new Scan();</div><div class="line">    scan.setCaching(20);</div><div class="line">       scan.setCacheBlocks(false);</div><div class="line"></div><div class="line">//设置起始行键搞定</div><div class="line">//如果是第一页数据，所以scan.setStartRow这句代码根本就没有任何意义，不用设置即可</div><div class="line">if (!StringUtils.isBlank(startRow)) &#123;</div><div class="line"></div><div class="line">//如果用户不传入startRow，或者传入一个非法的startRow，还是按照规则返回第一页</div><div class="line">scan.setStartRow(startRow.getBytes());</div><div class="line">&#125;</div><div class="line">PrefixFilter prefix = new PrefixFilter(Bytes.toBytes(rowKey));//前缀过滤器</div><div class="line">FilterList filter1 = new FilterList(FilterList.Operator.MUST_PASS_ALL);</div><div class="line"></div><div class="line">//设置总数据条件</div><div class="line">Filter pageFilter = new PageFilter(size);</div><div class="line">filter1.addFilter(prefix);</div><div class="line">filter1.addFilter(pageFilter);</div><div class="line">scan.setFilter(filter1);</div><div class="line"></div><div class="line">ResultScanner scanner = table.getScanner(scan);</div><div class="line"></div><div class="line"></div><div class="line">return scanner;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public static List&lt;Map&lt;String, String&gt;&gt; scanTable(ResultScanner scan, Table table) &#123;</div><div class="line">// 结果集</div><div class="line">if (scan == null || table == null) &#123;</div><div class="line">return null;</div><div class="line">&#125;</div><div class="line"></div><div class="line">List&lt;Map&lt;String, String&gt;&gt; result = new ArrayList&lt;&gt;();</div><div class="line">Iterator&lt;Result&gt; it = scan.iterator();</div><div class="line">while (it.hasNext()) &#123;</div><div class="line">Map&lt;String, String&gt; m = null;// 用于存储每行的结果</div><div class="line">Result r = it.next();</div><div class="line">//String rowkey = Bytes.toString(r.getRow());</div><div class="line">// 得到一行的所有map,key=f1,value=Map&lt;Col,Map&lt;Timestamp,value&gt;&gt;</div><div class="line">NavigableMap&lt;byte[], NavigableMap&lt;byte[], NavigableMap&lt;Long, byte[]&gt;&gt;&gt; map = r.getMap();</div><div class="line">//</div><div class="line">for (Map.Entry&lt;byte[], NavigableMap&lt;byte[], NavigableMap&lt;Long, byte[]&gt;&gt;&gt; entry : map.entrySet()) &#123;</div><div class="line">m = new HashMap&lt;&gt;();</div><div class="line">;// 用于存储每个字段的结果</div><div class="line">// 得到列族</div><div class="line">//String f = Bytes.toString(entry.getKey());</div><div class="line">Map&lt;byte[], NavigableMap&lt;Long, byte[]&gt;&gt; colDataMap = entry.getValue();</div><div class="line">for (Map.Entry&lt;byte[], NavigableMap&lt;Long, byte[]&gt;&gt; ets : colDataMap.entrySet()) &#123;</div><div class="line"></div><div class="line">String c = Bytes.toString(ets.getKey());</div><div class="line">Map&lt;Long, byte[]&gt; tsValueMap = ets.getValue();</div><div class="line">for (Map.Entry&lt;Long, byte[]&gt; e : tsValueMap.entrySet()) &#123;</div><div class="line">//Long ts = e.getKey();</div><div class="line">String value = Bytes.toString(e.getValue());</div><div class="line">m.put(c, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">result.add(m);</div><div class="line">&#125;</div><div class="line">logger.info(table.getName() + &quot;查询成功&quot;);</div><div class="line">// System.out.println(result);</div><div class="line">return result;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写在前面&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.hbase查询批量数据是通过scan扫描表的，一般都是按条件查询，可以通过过滤器Filter锁定满足条件的数据。&lt;/p&gt;
&lt;p&gt;2.分页查询需要知道数据总数，而对于hbase这比较麻烦，不能像传统数据库一样直接count(*),暂时通过循环遍历去获得总数。&lt;br&gt;
    
    </summary>
    
    
      <category term="hbase" scheme="http://yoursite.com/tags/hbase/"/>
    
  </entry>
  
  <entry>
    <title>分布式NewSQL数据库Hbase入门介绍</title>
    <link href="http://yoursite.com/2018/07/01/%E5%88%86%E5%B8%83%E5%BC%8FNewSQL%E6%95%B0%E6%8D%AE%E5%BA%93Hbase%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2018/07/01/分布式NewSQL数据库Hbase入门介绍/</id>
    <published>2018-07-01T14:30:15.000Z</published>
    <updated>2018-08-17T02:41:00.579Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><ul><li><p>高可靠、高性能、可伸缩、实时读写、面向列的分布式NewSQL数据库</p></li><li><p>HBase是Hadoop Database，Google Bigtable的开源实现</p><a id="more"></a></li><li><p>NewSQL数据库</p><p>  –既具有NoSQL数据库的海量数据存储管理能力，又继承了关系数据库的SQL特性</p></li><li><p>列式存储</p><p>  –按列族存储，对Schema限制很少，可以自由添加列</p><p>  –适合存储海量的半结构化数据</p></li><li><p>Key-Value数据库</p><p>  –按Key的字典序顺序存储</p><p>  –主要通过Key实现数据的增删改查，以及扫库操作</p></li><li><p>采用HDFS为文件存储系统</p></li></ul><hr><!--more--><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h3><ul><li><p>海量数据存储</p><p>  –主要存储半结构化、非结构化的稀疏数据</p><p>  –PB以上数据规模</p></li><li><p>线性扩展</p><p>  –容量和处理能力随节点数量线性增长</p></li><li><p>高并发</p></li><li><p>高可用</p></li><li><p>数据实时随机读写</p></li><li><p>数据强一致性</p></li></ul><hr><h3 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3.适用场景"></a>3.适用场景</h3><ul><li><p>并发查询</p><p>  –海量数据</p><p>  –高并发</p><p>  –简单条件查询</p></li><li><p>半结构化和非结构化数据存储</p><p>  –10k~10M的半结构化和非结构化数据</p></li></ul><hr><h3 id="4-数据模型"><a href="#4-数据模型" class="headerlink" title="4.数据模型"></a>4.数据模型</h3><h6 id="4-1-表结构"><a href="#4-1-表结构" class="headerlink" title="4.1 表结构"></a>4.1 表结构</h6><ul><li>四维表：RowKey | 列族 | 列限定符 | 时间戳；</li></ul><p><img src="/img/hbase1.png" alt="image"></p><h6 id="4-2-基本概念介绍"><a href="#4-2-基本概念介绍" class="headerlink" title="4.2 基本概念介绍"></a>4.2 基本概念介绍</h6><ul><li><p>命名空间（Namespace）</p><p>  –命名空间是对表的逻辑分组，类似于关系数据库中的Database</p><p>  –利用命名空间，在多租户场景下可做到更好的资源和数据隔离</p></li><li><p>表（Table）</p><p>  –以“表”为单位组织数据</p><p>  –表由多行组成</p></li><li><p>行（Row）</p><p>  –表以“行”为单位组织数据</p><p>  –行由一个RowKey和多个列族组成</p></li><li><p>RowKey </p><p>  –行的主键，用于唯一地标识和定位行</p><p>  –各行按RowKey的字典序排列</p><p>  –大小64K</p></li><li><p>列族（Column Family）</p><p>  –表中数据按“列族”分组，每一行由若干列族组成，每个列族下可包含多个列</p><p>  –列族必须在建表时必须明确定义，如：create ‘student’, ‘basicinfo’, ‘courseinfo’</p><p>  –每一行的列族都相同，但列族不一定要包含数据</p><p>  –物理上，同一列族的数据存储在一起</p><p>  –权限控制、存储以及调优都在列族层面进行</p></li><li><p>列与列限定符（Columen &amp; Column Qualifier）</p><p>  –一个列族可包含多个列，且各列族可包含不同的列</p><p>  –列由列族和列限定符唯一指定，列名由列族名和列限定符组成，以“:”分隔</p><p>  –新列可按需动态加入列族</p></li><li><p>单元格（Cell）</p><p>  –单元格由RowKey、列族、列限定符唯一定位</p><p>  –单元格中存放若干<value, version=""></value,></p><p>  –单元格的值是有版本的，版本号为时间戳</p><p>  –单元格的值由{rowkey, column(=<column family="">+<column qualifier="">), version}来唯一定位</column></column></p><p>  –单元格的数据类型为字节数组byte[]</p></li><li><p>时间戳（Timestamp）</p><p>  –单元格的值利用时间戳来标识版本，时间戳具有唯一性</p><p>  –单元格内不同版本的值按时间倒序排列，最新的数据排在最前面</p><p>  –时间戳可以在数据写入时由系统自动赋值（精确到毫秒的当前系统时间），也可以由客户显式赋值，为了避免版本冲突，必须生成具有唯一性的时间戳</p><p>  –类型是 64位整型</p></li></ul><h6 id="4-3-特点"><a href="#4-3-特点" class="headerlink" title="4.3 特点"></a>4.3 特点</h6><ul><li><p>数据规模大</p><p>  –单表可容纳数十亿行，上百万列</p></li><li><p>无模式</p><p>  –每行可以有任意多的列，列可以动态增加，不同行可以有不同的列，列的类型没有限制</p></li><li><p>面向列族</p><p>  –面向列族的存储和权限控制，支持列族独立查询</p></li><li><p>稀疏</p><p>  –值为空的列不占存储空间，表可以非常稀疏</p></li><li><p>数据多版本</p><p>  –单元格的值可以有多个版本，利用时间戳来标识版本</p></li><li><p>数据无类型</p><p>  –所有数据以字节数组形式存储</p></li><li><p>线性模块化扩展方式</p></li><li><p>严格一致性读写</p></li><li><p>自动可配置表切割</p></li><li><p>区域服务器之间自动容灾</p></li><li><p>块缓存和布隆过滤器用于实时查询 </p></li><li><p>通过服务器端过滤器实现查询预测</p></li><li><p>可以通过hbase shell 和 java API访问</p></li><li><p>支持运行MapReduce任务基础类</p></li><li><p>可视化</p></li></ul><hr><h3 id="5-系统架构"><a href="#5-系统架构" class="headerlink" title="5.系统架构"></a>5.系统架构</h3><ul><li><p>HMaster（Master）</p><p>  –管理元数据</p><p>  –管理表的创建、删除和修改</p><p>  –为HRegionServer分配Region</p><p>  –负责HRegionServer的负载均衡</p><p>  –不处理Client的数据读写请求</p></li><li><p>HRegionServer（Slave）</p><p>  –系统运行过程中动态添加、删除HRegionServer</p><p>  –处理Client的数据读写请求</p><p>  –管理Region Split（分裂）</p><p>  –管理StoreFile Compaction（合并）</p></li><li><p>Zookeeper</p><p>  –实现HMaster高可用</p><p>  –监控HRegionServer的上下线信息，并通知HMaster</p><p>  –存储元数据的寻址入口</p><p>  –存储所有Region的寻址入口</p></li><li><p>Client</p><p>  –通过接口访问hbase</p><p>  –为了加快数据访问速度，将元数据、Region位置等信息缓存在Client Cache中</p></li></ul><h3 id="6-数据存储"><a href="#6-数据存储" class="headerlink" title="6.数据存储"></a>6.数据存储</h3><ul><li><p>Region<br>  –分布式存储和负载的最小单元</p><p>  –系统将表水平划分（按行）为多个Region，每个Region保存表的一段连续数据</p><p>  –默认每张表开始只有一个Region，随着数据不断写入，Region不断增大，当Region大小超过阀值时，当前Region会分裂成两个子Region</p><p>  –随着Region的不断增多，HMaster会将部分Region迁移到其他HRegionServer中，实现负载均衡</p><p>  –表通常被保存在多个HRegionServer的多个Region中</p></li><li><p>Store</p><p>  –一个Region由多个Store组成，每个Store存储一个列族</p><p>  –Store由内存中的MemStore和磁盘中的若干StoreFile组成</p><p>  –Region是分布式存储的最小单元，而Store是存储落盘的最小单元</p></li><li><p>MemStore与StoreFile</p><p>  –MemStore是Store的内存缓冲区，数据读写都先访问MemStore</p><p>  –StoreFile是MemStore的磁盘溢写文件，在HDFS中被称为HFile</p><p>  –写数据时，先写MemStore，当数据量超过阈值时，HRegionServer会将MemStore中的数据溢写磁盘，每次溢写都生成一个独立的StoreFile（HFile）</p><p>  –当Store中的StoreFile数量超过阈值时，HRegionServer会将若干小StoreFile合并为一个大StoreFile</p><p>  –当Region中最大Store的大小超过阈值时，HRegionServer会将其等分为两个子Region</p><p>  –Client读取数据时，先找MemStore，再找StoreFile</p></li></ul><p><img src="/img/hbase3.png" alt="image"></p><p><img src="/img/hbase4.png" alt="image"></p><p><img src="/img/hbase5.png" alt="image"></p><h3 id="7-读写过程"><a href="#7-读写过程" class="headerlink" title="7.读写过程"></a>7.读写过程</h3><blockquote><p>写过程</p></blockquote><p>（1）Client访问ZK，获取meta表所在Region的位置信息，并将该信息写入Client Cache</p><p>（2）Client读取meta表，根据Namespace、表名和RowKey，获取将要写入Region的位置信息，并将meta表写入Client Cache</p><p>（3）Client向HRegionServer发出写请求，HRegionServer先将操作和数据写入HLog（预写日志，<br>Write Ahead Log，WAL），再将数据写入MemStore，并保持有序</p><p>（4）当MemStore的数据量超过阈值时，将数据溢写磁盘，生成一个StoreFile文件</p><p>（5）当StoreFile的数量超过阈值时，将若干小StoreFile合并（Compact）为一个大StoreFile</p><p>（6）当Region中最大Store的大小超过阈值时，Region分裂（Split），等分成两个子Region</p><blockquote><p> 读过程</p></blockquote><p>（1）获取将要读取Region的位置信息（见写过程的第1、2步）</p><p>（2）Client向HRegionServer发出读请求</p><p>（3）HRegionServer先从MemStore读取数据，如未找到，再从StoreFile中</p><blockquote><p>StoreFile Compaction</p></blockquote><ul><li>含义：将Store中的全部或部分StoreFile合并为一个StoreFile的过程</li><li>目的：减少StoreFile数量，提升数据读取效率</li><li><p>触发<br>  –时机：</p><p>  ①Memstore溢写；</p><p>  ②后台线程周期性检查；</p><p>  ③手动，且触发后不能停止</p><p>  –条件：</p><p>  当Store中的StoreFile数量超过阈值时，触发StoreFile Compaction</p></li><li><p>Minor Compaction</p><p>  1.选取Store下的部分StoreFile（小的或相邻的），将它们合并为一个StoreFile</p><p>  2.不删除过期版本、delete marker数据</p><p>  3.速度较快，IO和带宽开销相对较低</p></li></ul><ul><li><p>Major Compaction</p><p>  1.将Store下的所有StoreFile合并为一个StoreFile</p><p>  2.删除过期版本、delete marker数据</p><p>  3.通常手动触发，选择集群比较空闲的时间操作</p><p>  4.速度很慢，IO和带宽开销非常高</p></li></ul><p><img src="/img/hbase6.png" alt="image"></p><blockquote><p>Region Split</p></blockquote><ul><li>含义：根据一定的触发条件和分裂策略，将Region划分为两个子Region的过程</li><li>目的：实现数据访问的负载均衡</li><li><p>方法：利用MiddleKey将当前Region划分为两个等分的子Region<br>-触发</p><p>  –时机：</p><p>  ①Memstore溢写；</p><p>  ②StoreFile Compaction；</p><p>  ③手动</p><p>  –条件：</p><p>  当Region中最大Store的大小超过阈值时，触发Region Split</p></li><li><p>Split会产生大量的I/O操作</p></li><li>Split开始前和Split完成后，HRegionServer都会通知HMaster</li><li>Split完成后，HRegionServer会更新meta表</li></ul><p><img src="/img/hbase7.png" alt="image"></p><blockquote><p>HLog</p></blockquote><ul><li>含义：以WAL（Write Ahead Log，预写日志）方式写数据时产生的日志文件</li><li>目的：HRegionServer意外宕机时的数据恢复</li><li>先写HLog，再写MemStore，最后写StoreFile</li><li>每个HRegionServer维护一个HLog</li><li>定期删除HLog过期数据</li><li><p>数据恢复过程</p><p>  1.HMaster通过ZooKeeper自动感知HRegionServer宕机</p><p>  2.HMaster处理HLog，针对不同的Region拆分HLog</p><p>  3.HMaster重新分配失效的Region</p><p>  4.通过HLog将尚未持久化的数据重新写入MemStore，然后溢写到StoreFile</p></li></ul><h4 id="本期Over"><a href="#本期Over" class="headerlink" title="本期Over!"></a>本期Over!</h4><hr><blockquote><p>下期介绍hbase安装与使用</p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1.概念&quot;&gt;&lt;/a&gt;1.概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;高可靠、高性能、可伸缩、实时读写、面向列的分布式NewSQL数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HBase是Hadoop Database，Google Bigtable的开源实现&lt;/p&gt;
    
    </summary>
    
    
      <category term="hbase" scheme="http://yoursite.com/tags/hbase/"/>
    
  </entry>
  
  <entry>
    <title>帆软报表左右键切换tab页</title>
    <link href="http://yoursite.com/2018/06/02/%E5%B8%86%E8%BD%AF%E6%8A%A5%E8%A1%A8%E5%B7%A6%E5%8F%B3%E9%94%AE%E5%88%87%E6%8D%A2tab%E9%A1%B5/"/>
    <id>http://yoursite.com/2018/06/02/帆软报表左右键切换tab页/</id>
    <published>2018-06-02T14:02:01.000Z</published>
    <updated>2018-06-20T06:29:33.468Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>在制作大屏的时候，有时候会遇到几个大屏轮播的情况，大屏轮播具体是通过tab页实现，我们可以实现隐藏tab标题，让tab定时切换。然而我们想实现通过按键随时切换tab页，更加灵活的去查看大屏，这时候需要通过js来实现。<br><a id="more"></a></p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ol><li>通过设置监听事件，监听按键：</li></ol><p>当按左键时，当前tab切换到上一个tab</p><p>按右键时，切换到下一tab</p><ol><li>极端情况：</li></ol><p>当目前在最后一个tab时，按右键，切换到第一个tab<br>当目前在第一个tab时，按左键，切换到最后一个tab</p><h3 id="具体js"><a href="#具体js" class="headerlink" title="具体js"></a>具体js</h3><p>1.首先在tabpane0添加tab切换事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout(function()&#123;</div><div class="line">        window.CardIndex=_g().getWidgetByName(&quot;tabpane0&quot;).getShowIndex();//记录当前的tab页索引</div><div class="line">&#125;,10);</div></pre></td></tr></table></figure><p>2.在tabpane0设置初始化事件</p><p>我这边有4个tab页，索引为0,1,2,3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">$(&apos;div:lt(1)&apos;,this.element.parent()).hide();//隐藏tab标题</div><div class="line">setTimeout(function()&#123;</div><div class="line">var aa = window.CardIndex;</div><div class="line">     document.onkeydown=function(event)&#123;</div><div class="line">  var e = event || window.event;</div><div class="line"> if(e &amp;&amp; e.keyCode==37)&#123; // 按 左键</div><div class="line"> if(aa==0)&#123;</div><div class="line">  _g().getWidgetByName(&quot;tabpane0&quot;).showCardByIndex(3);</div><div class="line">  aa=3;</div><div class="line"> &#125;else&#123;</div><div class="line">  _g().getWidgetByName(&quot;tabpane0&quot;).showCardByIndex(--aa);</div><div class="line"> &#125;</div><div class="line">     &#125;</div><div class="line">  if(e &amp;&amp; e.keyCode==39)&#123; // 按 右键</div><div class="line">  if(aa==3)&#123;</div><div class="line">  _g().getWidgetByName(&quot;tabpane0&quot;).showCardByIndex(0);</div><div class="line">  aa=0;</div><div class="line">  &#125;else&#123;</div><div class="line">   _g().getWidgetByName(&quot;tabpane0&quot;).showCardByIndex(++aa);</div><div class="line">  &#125;</div><div class="line">     &#125;</div><div class="line">&#125;;&#125;,10);</div></pre></td></tr></table></figure><p>如上，根据你们tab页的个数，调整值就行，比如3个tab页，最大的索引就是2。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h3&gt;&lt;p&gt;在制作大屏的时候，有时候会遇到几个大屏轮播的情况，大屏轮播具体是通过tab页实现，我们可以实现隐藏tab标题，让tab定时切换。然而我们想实现通过按键随时切换tab页，更加灵活的去查看大屏，这时候需要通过js来实现。&lt;br&gt;
    
    </summary>
    
    
      <category term="帆软报表" scheme="http://yoursite.com/tags/%E5%B8%86%E8%BD%AF%E6%8A%A5%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式消息队列kafka入门</title>
    <link href="http://yoursite.com/2018/06/01/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/06/01/分布式消息队列kafka入门/</id>
    <published>2018-06-01T15:00:03.000Z</published>
    <updated>2018-08-17T02:26:07.425Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><blockquote><p>基于发布/订阅的分布式消息系统</p><p>由Linkedin开发，用Scala语言编写</p></blockquote><hr><a id="more"></a><h3 id="2-特性"><a href="#2-特性" class="headerlink" title="2.特性"></a>2.特性</h3><h6 id="2-1-消息持久化："><a href="#2-1-消息持久化：" class="headerlink" title="2.1 消息持久化："></a>2.1 消息持久化：</h6><p>采用时间复杂度O(1)的磁盘存储结构，即使TB级以上数据也能保证常数时间的访问速度</p><h6 id="2-2-高吞吐："><a href="#2-2-高吞吐：" class="headerlink" title="2.2 高吞吐："></a>2.2 高吞吐：</h6><p>即使在廉价的商用机器上，也能达到单机每秒10万条消息的传输</p><h6 id="2-3-高容错：多分区多副本"><a href="#2-3-高容错：多分区多副本" class="headerlink" title="2.3 高容错：多分区多副本"></a>2.3 高容错：多分区多副本</h6><h6 id="2-4-易扩展：新增机器，集群无需停机，自动感知"><a href="#2-4-易扩展：新增机器，集群无需停机，自动感知" class="headerlink" title="2.4 易扩展：新增机器，集群无需停机，自动感知"></a>2.4 易扩展：新增机器，集群无需停机，自动感知</h6><h6 id="2-5-同时支持离线、实时数据处理"><a href="#2-5-同时支持离线、实时数据处理" class="headerlink" title="2.5  同时支持离线、实时数据处理"></a>2.5  同时支持离线、实时数据处理</h6><hr><h3 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h3><h6 id="3-1-异步通信"><a href="#3-1-异步通信" class="headerlink" title="3.1 异步通信"></a>3.1 异步通信</h6><ul><li>将消息放入Kafka，可以不立即处理</li></ul><h6 id="3-2应用解耦"><a href="#3-2应用解耦" class="headerlink" title="3.2应用解耦"></a>3.2应用解耦</h6><ul><li>在应用处理过程中插入一个隐含的、基于数据的接口层</li></ul><h6 id="3-3-峰值处理"><a href="#3-3-峰值处理" class="headerlink" title="3.3 峰值处理"></a>3.3 峰值处理</h6><ul><li>使关键应用能够顶住访问峰值，不会因超出负荷而崩溃</li></ul><p><img src="/img/kafka1.png" alt="image"></p><hr><h3 id="4-基本概念"><a href="#4-基本概念" class="headerlink" title="4.基本概念"></a>4.基本概念</h3><h6 id="4-1-Broker（代理）"><a href="#4-1-Broker（代理）" class="headerlink" title="4.1 Broker（代理）"></a>4.1 Broker（代理）</h6><ul><li>Kafka的一个实例或节点，一个或多个Broker组成一个Kafka集群</li></ul><h6 id="4-2-Topic（主题）"><a href="#4-2-Topic（主题）" class="headerlink" title="4.2 Topic（主题）"></a>4.2 Topic（主题）</h6><ul><li><p>Topic是Kafka中同一类数据的集合，相当于数据库中的表</p></li><li><p>Producer将同一类数据写入同一个Topic，Consumer从同一个Topic中读取同类数据</p></li><li><p>Topic是逻辑概念，用户只需指定Topic就可以生产或消费数据，不必关心数据存于何处</p></li></ul><h6 id="4-3-Partition（分区）"><a href="#4-3-Partition（分区）" class="headerlink" title="4.3 Partition（分区）"></a>4.3 Partition（分区）</h6><ul><li><p>分区是一个有序的、不可修改的消息队列，分区内消息有序存储</p></li><li><p>一个Topic可分为多个分区，相当于把一个数据集分成多份，分别存储不同的分区中</p></li><li><p>Parition是物理概念，每个分区对应一个文件夹，其中存储分区的数据和索引文件</p></li></ul><h6 id="4-4-Replication（副本）"><a href="#4-4-Replication（副本）" class="headerlink" title="4.4 Replication（副本）"></a>4.4 Replication（副本）</h6><ul><li>一个分区可以设置多个副本，副本存储在不同的Broke</li></ul><h6 id="4-5-Producer（消息生产者）"><a href="#4-5-Producer（消息生产者）" class="headerlink" title="4.5 Producer（消息生产者）"></a>4.5 Producer（消息生产者）</h6><ul><li>向Broker发布消息的客户端</li></ul><h6 id="4-6-Consumer（消息消费者）"><a href="#4-6-Consumer（消息消费者）" class="headerlink" title="4.6 Consumer（消息消费者）"></a>4.6 Consumer（消息消费者）</h6><ul><li>从Broker消费消息的客户端</li></ul><h6 id="4-7-Consumer-Group（CG，消费者组）"><a href="#4-7-Consumer-Group（CG，消费者组）" class="headerlink" title="4.7 Consumer Group（CG，消费者组）"></a>4.7 Consumer Group（CG，消费者组）</h6><ul><li><p>每个Consumer都隶属于一个特定的CG</p></li><li><p>一条消息可以发送给多个不同的CG，但一个CG中只能有一个Consumer读取该消息</p></li></ul><h6 id="4-8-Zookeeper"><a href="#4-8-Zookeeper" class="headerlink" title="4.8 Zookeeper"></a>4.8 Zookeeper</h6><ul><li><p>Kafka将元数据保存在Zookeeper中</p></li><li><p>负责Kafka集群管理，包括配置管理、动态扩展、Broker负载均衡、Leader选举，以及Consumer Group变化时的Rebalance等</p></li></ul><hr><h3 id="5-工作机制"><a href="#5-工作机制" class="headerlink" title="5.工作机制"></a>5.工作机制</h3><p><img src="/img/kafka2.png" alt="image"></p><ul><li><p>消息在Broker中按Topic（主题）进行分类，相当于为每个消息打个标签</p></li><li><p>一个Topic可划分为多个Partition（分区）</p></li><li><p>每个Partition可以有多个Replication（副本）</p></li><li><p>消息存储在Broker的某一Topic的某一Partition中，同时存在多个副本</p></li></ul><p><img src="/img/kafka3.png" alt="image"></p><ul><li><p>Partition是一个FIFO队列，写入消息采用在队列尾部追加的方式，消费消息采用在队列头部顺序读取的方式</p></li><li><p>一个Topic可分为多个Partition，仅保证同一分区内消息有序存储，不保证Topic整体（多个分区之间）有序</p></li></ul><p><img src="/img/kafka4.png" alt="image"></p><ul><li><p>为了加快读取速度，多个Consumer可划分为一个组（Consumer Group, CG），并行消费同一个Topic</p></li><li><p>一个Topic可以被多个CG订阅，CG之间是平等的，即一个消息可同时被多个CG消费</p></li><li><p>一个CG中可以有多个Consumer，CG中的Consumer之间是竞争关系，即一个消息在一个CG<br>中只能被一个Consumer消费</p></li></ul><p><img src="/img/kafka5.png" alt="image"></p><hr><h3 id="6-数据存储"><a href="#6-数据存储" class="headerlink" title="6.数据存储"></a>6.数据存储</h3><h6 id="6-1-每个Partition副本都是一个目录，目录中包含若干Segment文件"><a href="#6-1-每个Partition副本都是一个目录，目录中包含若干Segment文件" class="headerlink" title="6.1 每个Partition副本都是一个目录，目录中包含若干Segment文件"></a>6.1 每个Partition副本都是一个目录，目录中包含若干Segment文件</h6><h6 id="6-2-Segment（段文件）"><a href="#6-2-Segment（段文件）" class="headerlink" title="6.2 Segment（段文件）"></a>6.2 Segment（段文件）</h6><ul><li><p>Segment文件是Kafka的最小数据存储单元，一个Partition包含多个Segment文件</p></li><li><p>Segment文件由以Message在Partition中的起始偏移量命名的数据文件（<em>.log）和索引文件（</em>.index、*.timeindex）组成</p></li></ul><h6 id="6-3-Offset（偏移量）"><a href="#6-3-Offset（偏移量）" class="headerlink" title="6.3 Offset（偏移量）"></a>6.3 Offset（偏移量）</h6><ul><li><p>Offset是用于定位分区中消息的顺序编号</p></li><li><p>Offset用于在分区中唯一标识消息</p></li><li><p>使用Zookeeper维护Offset</p></li></ul><h6 id="6-4-Kafka索引"><a href="#6-4-Kafka索引" class="headerlink" title="6.4 Kafka索引"></a>6.4 Kafka索引</h6><p>为了提高消息写入和查询速度，为每个Partition创建索引，索引文件存储在Partition文件夹下</p><ul><li><p>偏移量索引</p><p>  – 文件以offset偏移量为名称，以index为后缀</p><p>  – 索引内容格式：offset,position</p><p>  – 采用稀疏存储方式</p></li><li><p>时间戳索引</p><p>  – 文件以timeindex为后缀</p><p>  – 索引内容格式：timestamp,offset</p><p>  – 采用稀疏存储方式</p></li></ul><p><img src="/img/kafka6.png" alt="image"></p><hr><h3 id="7-kafka高可用"><a href="#7-kafka高可用" class="headerlink" title="7.kafka高可用"></a>7.kafka高可用</h3><h6 id="7-1-多分区多副本"><a href="#7-1-多分区多副本" class="headerlink" title="7.1 多分区多副本"></a>7.1 多分区多副本</h6><ul><li><p>Kafka早期版本没有Replication概念，一旦某个Brocker宕机，其上的分区数据就可能丢失</p></li><li><p>一个Topic可以有多个分区，每个分区可以有多个副本，副本存储在不同的Broker中</p></li><li><p>从一个分区的多个副本中选举一个PartitionLeader，由Leader负责读写，其他副本作为Follower从Leader同步消息</p></li></ul><h6 id="7-2-Kafka-Controller-Leader选举"><a href="#7-2-Kafka-Controller-Leader选举" class="headerlink" title="7.2 Kafka Controller Leader选举"></a>7.2 Kafka Controller Leader选举</h6><ul><li><p>每个Broker启动时都会创建一个Kafka Controller进程</p></li><li><p>通过Zookeeper，从Kafka集群中选举出一个Broker作为Kafka Controller Leader</p></li><li><p>Kafka Controller Leader负责管理Kafka集群的分区和副本状态，避免分区副本直接在Zookeeper上注册Watcher和竞争创建临时Znode，导致Zookeeper集群负载过重</p></li></ul><h6 id="7-3-Kafka-Partition-Leader选举"><a href="#7-3-Kafka-Partition-Leader选举" class="headerlink" title="7.3 Kafka Partition Leader选举"></a>7.3 Kafka Partition Leader选举</h6><ul><li><p>Kafka Controller Leader负责Partition Leader的选举</p></li><li><p>ISR列表（In Sync Replica）</p><p>  – ISR是Zookeeper中的候选副本同步列表，负责保存候选副本（Partition Follower）的状态信息</p><p>  – Partition Leader负责跟踪和维护ISR</p><p>  – Partition Follower定期从Leader同步数据 ，若Follower心跳超时或消息落后太多，将被移除出ISR</p></li><li><p>Partition Leader挂掉后，Kafka Controller Leader从ISR中选择一个Follower作为新的Leader</p></li></ul><h4 id="本期Over"><a href="#本期Over" class="headerlink" title="本期Over!"></a>本期Over!</h4><hr><blockquote><p>下期介绍kafka安装与使用</p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1.概念&quot;&gt;&lt;/a&gt;1.概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;基于发布/订阅的分布式消息系统&lt;/p&gt;
&lt;p&gt;由Linkedin开发，用Scala语言编写&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>js跳出当前frame并全屏显示</title>
    <link href="http://yoursite.com/2018/05/20/js%E8%B7%B3%E5%87%BA%E5%BD%93%E5%89%8Dframe%E5%B9%B6%E5%85%A8%E5%B1%8F%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2018/05/20/js跳出当前frame并全屏显示/</id>
    <published>2018-05-20T01:30:00.000Z</published>
    <updated>2018-06-20T03:14:05.101Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>以下是跳出当前frame，并全屏显示的js<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">window.isflsgrn = false;</div><div class="line">//ie11以下是否进入全屏标志，true为全屏状态，false为非全屏状态</div><div class="line">window.ieIsfSceen = false;</div><div class="line">//ie11是否进入全屏标志，true为全屏状态，false为非全屏状态</div><div class="line">//跨浏览器返回当前 document 是否进入了可以请求全屏模式的状态</div><div class="line">function fullscreenEnable()&#123;</div><div class="line">var isFullscreen = document.fullscreenEnabled ||</div><div class="line">window.fullScreen ||</div><div class="line">document.mozFullscreenEnabled ||</div><div class="line">document.webkitIsFullScreen;</div><div class="line">return isFullscreen;</div><div class="line">&#125;</div><div class="line">//全屏</div><div class="line">var fScreen = function()&#123;</div><div class="line">var docElm = document.documentElement;</div><div class="line">if (docElm.requestFullscreen) &#123;</div><div class="line">  docElm.requestFullscreen();</div><div class="line">&#125;</div><div class="line">else if (docElm.msRequestFullscreen) &#123;</div><div class="line">  docElm.msRequestFullscreen();</div><div class="line">  ieIsfSceen = true;</div><div class="line">&#125;</div><div class="line">else if (docElm.mozRequestFullScreen) &#123;</div><div class="line">  docElm.mozRequestFullScreen();</div><div class="line">&#125;</div><div class="line">else if (docElm.webkitRequestFullScreen) &#123;</div><div class="line">  docElm.webkitRequestFullScreen();</div><div class="line">&#125;else &#123;</div><div class="line">//对不支持全屏API浏览器的处理，</div><div class="line">//隐藏不需要显示的元素</div><div class="line">    window.parent.hideTopBottom();</div><div class="line">    isflsgrn = true;</div><div class="line">    $(&quot;#fsbutton&quot;).text(&quot;退出全屏&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//退出全屏</div><div class="line">var cfScreen = function()&#123;</div><div class="line">if (document.exitFullscreen) &#123;</div><div class="line">  document.exitFullscreen();</div><div class="line">&#125;</div><div class="line">else if (document.msExitFullscreen) &#123;</div><div class="line">  document.msExitFullscreen();</div><div class="line">&#125;</div><div class="line">else if (document.mozCancelFullScreen) &#123;</div><div class="line">  document.mozCancelFullScreen();</div><div class="line">&#125;</div><div class="line">else if (document.webkitCancelFullScreen) &#123;</div><div class="line">  document.webkitCancelFullScreen();</div><div class="line">&#125;else &#123;</div><div class="line">  window.parent.showTopBottom();</div><div class="line">  isflsgrn = false;</div><div class="line">  $(&quot;#fsbutton&quot;).text(&quot;全屏&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//全屏按钮点击事件</div><div class="line">$(&quot;#fsbutton&quot;).click(function()&#123;</div><div class="line">var isfScreen = fullscreenEnable();</div><div class="line">if(!isfScreen &amp;&amp; isflsgrn == false)&#123;</div><div class="line">  if (ieIsfSceen == true) &#123;</div><div class="line">    document.msExitFullscreen();</div><div class="line">    ieIsfSceen = false;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  fScreen();</div><div class="line">&#125;else&#123;</div><div class="line">  cfScreen();</div><div class="line">&#125;</div><div class="line">&#125;)</div><div class="line">//键盘操作</div><div class="line">/*$(document).keydown(function (event) &#123;</div><div class="line">if(event.keyCode == 27 &amp;&amp; ieIsfSceen == true)&#123;</div><div class="line">  ieIsfSceen = false;</div><div class="line">&#125;</div><div class="line">&#125;);*/</div><div class="line">//监听状态变化</div><div class="line">if (window.addEventListener) &#123;</div><div class="line">document.addEventListener(&apos;fullscreenchange&apos;, function()&#123; </div><div class="line">  if($(&quot;#fsbutton&quot;).text() == &quot;全屏&quot;)&#123;</div><div class="line">    $(&quot;#fsbutton&quot;).text(&quot;退出全屏&quot;); </div><div class="line">  &#125;else&#123;</div><div class="line">    $(&quot;#fsbutton&quot;).text(&quot;全屏&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">document.addEventListener(&apos;webkitfullscreenchange&apos;, function()&#123; </div><div class="line">  if($(&quot;#fsbutton&quot;).text() == &quot;全屏&quot;)&#123;</div><div class="line">    $(&quot;#fsbutton&quot;).text(&quot;退出全屏&quot;); </div><div class="line">  &#125;else&#123;</div><div class="line">    $(&quot;#fsbutton&quot;).text(&quot;全屏&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">document.addEventListener(&apos;mozfullscreenchange&apos;, function()&#123; </div><div class="line">  if($(&quot;#fsbutton&quot;).text() == &quot;全屏&quot;)&#123;</div><div class="line">   $(&quot;#fsbutton&quot;).text(&quot;退出全屏&quot;); </div><div class="line">  &#125;else&#123;</div><div class="line">    $(&quot;#fsbutton&quot;).text(&quot;全屏&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">document.addEventListener(&apos;MSFullscreenChange&apos;, function()&#123; </div><div class="line">  if($(&quot;#fsbutton&quot;).text() == &quot;全屏&quot;)&#123;</div><div class="line">    $(&quot;#fsbutton&quot;).text(&quot;退出全屏&quot;); </div><div class="line">  &#125;else&#123;</div><div class="line">    $(&quot;#fsbutton&quot;).text(&quot;全屏&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下是跳出当前frame，并全屏显示的js&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>redis安装与配置</title>
    <link href="http://yoursite.com/2018/05/11/redis%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/05/11/redis安装与配置/</id>
    <published>2018-05-11T14:13:05.000Z</published>
    <updated>2018-07-17T04:46:45.731Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h4 id="1-下载"><a href="#1-下载" class="headerlink" title="1.下载"></a>1.下载</h4><p>下载地址：<a href="http://redis.io/download" target="_blank" rel="external">http://redis.io/download</a></p><p>或者使用命定下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://download.redis.io/releases/redis-4.0.10.tar.gz</div></pre></td></tr></table></figure><a id="more"></a><h4 id="2-解压至任一目录"><a href="#2-解压至任一目录" class="headerlink" title="2.解压至任一目录"></a>2.解压至任一目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -xvf redis-4.0.10.tar.gz</div></pre></td></tr></table></figure><h4 id="3-编译并安装"><a href="#3-编译并安装" class="headerlink" title="3.编译并安装"></a>3.编译并安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd redis-4.0.10</div><div class="line">make</div><div class="line">cd src</div><div class="line">make install PREFIX=/usr/local/redis</div></pre></td></tr></table></figure><p>注意：make编译如果失败，因为没有安装gcc服务<br>安装gcc:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install gcc</div></pre></td></tr></table></figure><p>查看安装是否成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm -qa | grep gcc</div></pre></td></tr></table></figure><h4 id="4-将redis-4-0-10文件夹下配置文件移动到redis安装目录下"><a href="#4-将redis-4-0-10文件夹下配置文件移动到redis安装目录下" class="headerlink" title="4.将redis-4.0.10文件夹下配置文件移动到redis安装目录下"></a>4.将redis-4.0.10文件夹下配置文件移动到redis安装目录下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ..</div><div class="line">mv redis.conf /usr/local/redis/etc/</div></pre></td></tr></table></figure><h4 id="5-启动服务、配置"><a href="#5-启动服务、配置" class="headerlink" title="5.启动服务、配置"></a>5.启动服务、配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/redis/bin/redis-server  /usr/local/redis/etc/redis.conf</div></pre></td></tr></table></figure><p>第一个是启动redis服务器</p><p>第二个是启动服务器所需的配置</p><h4 id="6-默认情况，Redis不是在后台运行，需要把redis放在后台运行"><a href="#6-默认情况，Redis不是在后台运行，需要把redis放在后台运行" class="headerlink" title="6.默认情况，Redis不是在后台运行，需要把redis放在后台运行"></a>6.默认情况，Redis不是在后台运行，需要把redis放在后台运行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vim /usr/local/redis/etc/redis.conf </div><div class="line">将daemonize的值改为yes</div></pre></td></tr></table></figure><p><img src="/img/redis1.png" alt="image"></p><h4 id="7-让redis开机自启"><a href="#7-让redis开机自启" class="headerlink" title="7.让redis开机自启"></a>7.让redis开机自启</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim /etc/rc.local</div><div class="line">加入</div><div class="line">/usr/local/redis/bin/redis-server  /usr/local/redis/etc/redis.conf</div></pre></td></tr></table></figure><p><img src="/img/redis2.png" alt="image"></p><p>修改权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x /etc/rc.d/rc.local</div></pre></td></tr></table></figure></p><h4 id="8-客户端链接"><a href="#8-客户端链接" class="headerlink" title="8.客户端链接"></a>8.客户端链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/redis/bin/redis-cli</div></pre></td></tr></table></figure><p>启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了。 比如：<br><img src="/img/redis3.png" alt="image"></p><h4 id="9-停止服务"><a href="#9-停止服务" class="headerlink" title="9.停止服务"></a>9.停止服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/usr/local/redis/bin/redis-cli shutdown</div><div class="line">或者pkill redis-server</div></pre></td></tr></table></figure><h4 id="10、-usr-local-redis-bin目录下的几个关键文件"><a href="#10、-usr-local-redis-bin目录下的几个关键文件" class="headerlink" title="10、/usr/local/redis/bin目录下的几个关键文件"></a>10、/usr/local/redis/bin目录下的几个关键文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">redis-benchmark：redis性能测试工具</div><div class="line">redis-check-aof：检查aof日志的工具</div><div class="line">redis-check-dump：检查rdb日志的工具</div><div class="line">redis-cli：连接用的客户端</div><div class="line">redis-server：redis服务进程</div></pre></td></tr></table></figure><h4 id="11-conf-配置项介绍"><a href="#11-conf-配置项介绍" class="headerlink" title="11.conf 配置项介绍"></a>11.conf 配置项介绍</h4><p>daemonize：如需要在后台运行，把该项的值改为yes<br>pdifile：把pid文件放在/var/run/redis.pid，可以配置到其他地址<br>bind：指定redis只接收来自该IP的请求，如果不设置，那么将处理所有请求，在生产环节中最好设置该项<br>port：监听端口，默认为6379<br>timeout：设置客户端连接时的超时时间，单位为秒<br>loglevel：等级分为4级，debug，revbose，notice和warning。生产环境下一般开启notice<br>logfile：配置log文件地址，默认使用标准输出，即打印在命令行终端的端口上<br>database：设置数据库的个数，默认使用的数据库是0<br>save：设置redis进行数据库镜像的频率<br>rdbcompression：在进行镜像备份时，是否进行压缩<br>dbfilename：镜像备份文件的文件名<br>dir：数据库镜像备份的文件放置的路径<br>slaveof：设置该数据库为其他数据库的从数据库<br>masterauth：当主数据库连接需要密码验证时，在这里设定<br>requirepass：设置客户端连接后进行任何其他指定前需要使用的密码<br>maxclients：限制同时连接的客户端数量<br>maxmemory：设置redis能够使用的最大内存<br>appendonly：开启appendonly模式后，redis会把每一次所接收到的写操作都追加到appendonly.aof文件中，当redis重新启动时，会从该文件恢复出之前的状态<br>appendfsync：设置appendonly.aof文件进行同步的频率<br>vm_enabled：是否开启虚拟内存支持<br>vm_swap_file：设置虚拟内存的交换文件的路径<br>vm_max_momery：设置开启虚拟内存后，redis将使用的最大物理内存的大小，默认为0<br>vm_page_size：设置虚拟内存页的大小<br>vm_pages：设置交换文件的总的page数量<br>vm_max_thrrads：设置vm IO同时使用的线程数量</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-下载&quot;&gt;&lt;a href=&quot;#1-下载&quot; class=&quot;headerlink&quot; title=&quot;1.下载&quot;&gt;&lt;/a&gt;1.下载&lt;/h4&gt;&lt;p&gt;下载地址：&lt;a href=&quot;http://redis.io/download&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://redis.io/download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或者使用命定下载：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;wget http://download.redis.io/releases/redis-4.0.10.tar.gz&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>js判断文件格式及文件大小</title>
    <link href="http://yoursite.com/2018/04/22/js%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F/"/>
    <id>http://yoursite.com/2018/04/22/js判断文件格式及文件大小/</id>
    <published>2018-04-22T15:01:23.000Z</published>
    <updated>2018-07-17T07:18:51.392Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h6 id="见代码！"><a href="#见代码！" class="headerlink" title="见代码！"></a>见代码！</h6><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">function fileChange(target)&#123; </div><div class="line">var isIE = /msie/i.test(navigator.userAgent) &amp;&amp; !window.opera; //判断是否为ie浏览器</div><div class="line">var fileSize = 0; //文件大小</div><div class="line">var filetypes =[&quot;.sh&quot;,&quot;.sql&quot;,&quot;.rar&quot;,&quot;.txt&quot;,&quot;.zip&quot;,&quot;.doc&quot;,&quot;.ppt&quot;,&quot;.xls&quot;,&quot;.pdf&quot;,&quot;.docx&quot;,&quot;.xlsx&quot;,&quot;.jpg&quot;,&quot;.png&quot;]; //定义文件格式</div><div class="line">var filepath = target.value; </div><div class="line">var filemaxsize = 1024*2;//2M </div><div class="line"></div><div class="line">if(filepath)&#123; </div><div class="line">var isnext = false; </div><div class="line">var fileend = filepath.substring(filepath.indexOf(&quot;.&quot;)); </div><div class="line">if(filetypes &amp;&amp; filetypes.length&gt;0)&#123; </div><div class="line">for(var i =0; i&lt;filetypes.length;i++)&#123; </div><div class="line">if(filetypes[i]==fileend)&#123; </div><div class="line">isnext = true; </div><div class="line">break; </div><div class="line">&#125; </div><div class="line">&#125; </div><div class="line">&#125; </div><div class="line">if(!isnext)&#123; </div><div class="line">alert(&quot;不接受此文件类型&quot;); </div><div class="line">target.value =&quot;&quot;; </div><div class="line">return false; </div><div class="line">&#125; </div><div class="line">&#125;else&#123; </div><div class="line">return false; </div><div class="line">&#125; </div><div class="line"></div><div class="line"></div><div class="line">if (isIE &amp;&amp; !target.files) &#123; </div><div class="line">var filePath = target.value; </div><div class="line">var fileSystem = new ActiveXObject(&quot;Scripting.FileSystemObject&quot;); </div><div class="line">if(!fileSystem.FileExists(filePath))&#123; </div><div class="line">alert(&quot;附件不存在，请重新输入！&quot;); </div><div class="line">return false; </div><div class="line">&#125; </div><div class="line">var file = fileSystem.GetFile (filePath); </div><div class="line">fileSize = file.Size; </div><div class="line">&#125; else &#123; </div><div class="line">fileSize = target.files[0].size; </div><div class="line">&#125; </div><div class="line"></div><div class="line">var size = fileSize / 1024; </div><div class="line">if(size&gt;filemaxsize)&#123; </div><div class="line">alert(&quot;附件大小不能大于&quot;+filemaxsize/1024+&quot;M！&quot;); </div><div class="line">target.value =&quot;&quot;; </div><div class="line">return false; </div><div class="line">&#125; </div><div class="line">if(size&lt;=0)&#123; </div><div class="line">alert(&quot;附件大小不能为0M！&quot;); </div><div class="line">target.value =&quot;&quot;; </div><div class="line">return false; </div><div class="line">&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;见代码！&quot;&gt;&lt;a href=&quot;#见代码！&quot; class=&quot;headerlink&quot; title=&quot;见代码！&quot;&gt;&lt;/a&gt;见代码！&lt;/h6&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本调用jar包打印乘法表</title>
    <link href="http://yoursite.com/2018/04/09/shell%E8%84%9A%E6%9C%AC%E8%B0%83%E7%94%A8jar%E5%8C%85%E6%89%93%E5%8D%B0%E4%B9%98%E6%B3%95%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/04/09/shell脚本调用jar包打印乘法表/</id>
    <published>2018-04-09T11:23:00.000Z</published>
    <updated>2018-06-20T03:28:45.853Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>以下是脚本代码。。<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">#声明脚本</div><div class="line"></div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">#打印&quot;------cfb---------&quot;</div><div class="line">echo &quot;------cfb---------&quot;</div><div class="line"></div><div class="line">#java环境变量</div><div class="line">JAVA_HOME=/usr/java/jdk1.8.0_11</div><div class="line">CLASSPATH=$JAVA_HOME/bin</div><div class="line"></div><div class="line">#指定需要执行jar包的位置，可自行设置</div><div class="line"></div><div class="line">JARPATH=/home/haha/Desktop</div><div class="line"></div><div class="line">#环境变量的标准格式</div><div class="line"></div><div class="line">CLASSPATH=$CLASSPATH:$JARPATH/cfb.jar</div><div class="line"></div><div class="line">#export用来设置或者新增环境变量,而且仅限于本次登录操作,不写的话,找不到main类</div><div class="line"></div><div class="line">export CLASSPATH=$CLASSPATH</div><div class="line"></div><div class="line">#打印环境变量</div><div class="line">echo $CLASSPATH</div><div class="line"></div><div class="line">#执行jingdian.CfbDemo类中main方法</div><div class="line">java -Xms50m -Xmx250m jingdian.CfbDemo</div><div class="line"></div><div class="line">#退出</div><div class="line"></div><div class="line">exit</div></pre></td></tr></table></figure><p>最终打印效果<br><img src="/img/cfb.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下是脚本代码。。&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数列3种实现方式</title>
    <link href="http://yoursite.com/2018/01/10/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%973%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/01/10/斐波那契数列3种实现方式/</id>
    <published>2018-01-10T08:22:14.000Z</published>
    <updated>2018-01-11T08:26:06.056Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p> 斐波那契数列又称黄金分割数列、因数学家列昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”。<br>指的是这样一个数列：1、1、2、3、5、8、13、21、34、……<br>在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>下面简单介绍下实现num以内的斐波那契数列3种方式：</p><hr><h3 id="1-递归算法："><a href="#1-递归算法：" class="headerlink" title="1.递归算法："></a>1.递归算法：</h3><pre><code>public  static void findAll(int num){    List&lt;Integer&gt; nums = new ArrayList&lt;Integer&gt;();    for(int i=1;i&lt;=num;i++){        if(F(i)&gt;num) break;        nums.add(F(i));    }    System.out.println(nums);}//递归查询public static int F(int i){    if(i ==1){        return 1;    }    if(i==2){        return 1;    }    if(i&gt;=3){    return F(i-1)+F(i-2);    }    return -1;}</code></pre><hr><h3 id="2-备忘录算法-递归算法"><a href="#2-备忘录算法-递归算法" class="headerlink" title="2.备忘录算法+递归算法"></a>2.备忘录算法+递归算法</h3><pre><code>public  static void findAll(int num){    List&lt;Integer&gt; nums = new ArrayList&lt;Integer&gt;();    Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();    for(int i=1;i&lt;=num;i++){        if(F(i,map)&gt;num) break;        nums.add(F(i,map));    }    System.out.println(nums);    }//递归查询,添加备忘录，避免重复查询F(i)public static int F(int i,Map&lt;Integer,Integer&gt; map){    if(i&lt;1){        return -1;    }    if(i ==1){        return 1;    }    if(i==2){        return 1;    }    if(map.containsKey(i)){        return map.get(i);    }else{        int value = F(i-1,map) +F(i-2,map);        map.put(i, value);        return value;    }}</code></pre><hr><h3 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3.动态规划"></a>3.动态规划</h3><pre><code>public  static void findAll(int num){    List&lt;Integer&gt; nums = new ArrayList&lt;Integer&gt;();    if(num==1){        System.out.println(&quot;[&quot;+num+&quot;]&quot;);    }    if(num==2){        System.out.println(&quot;[1,1]&quot;);    }    if(num&gt;=3){        int a =1 ,b =1;        nums.add(a);        nums.add(b);        for(int i=3;i&lt;=num;i++){            int next = a+b;            a=b;            b=next;            if(next&gt;=num){                break;            }        nums.add(next);        }        System.out.println(nums);    }}</code></pre><p>以上三种方式，效率依次递增。建议使用第三种方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介：&quot;&gt;&lt;a href=&quot;#简介：&quot; class=&quot;headerlink&quot; title=&quot;简介：&quot;&gt;&lt;/a&gt;简介：&lt;/h3&gt;&lt;p&gt; 斐波那契数列又称黄金分割数列、因数学家列昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”。&lt;br&gt;指的是这样一个数列：1、1、2、3、5、8、13、21、34、……&lt;br&gt;在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n&amp;gt;=2，n∈N*）&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>帆软报表大屏制作</title>
    <link href="http://yoursite.com/2017/10/09/%E5%B8%86%E8%BD%AF%E6%8A%A5%E8%A1%A8%E5%A4%A7%E5%B1%8F%E5%88%B6%E4%BD%9C/"/>
    <id>http://yoursite.com/2017/10/09/帆软报表大屏制作/</id>
    <published>2017-10-09T08:25:14.000Z</published>
    <updated>2018-01-16T07:42:25.987Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.finereport8.0</div><div class="line">2.java</div><div class="line">3.mysql</div></pre></td></tr></table></figure><a id="more"></a><h3 id="帆软报表简介"><a href="#帆软报表简介" class="headerlink" title="帆软报表简介"></a>帆软报表简介</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FineReport是集数据展示（报表）和数据录入(表单)功能于一身，能够制作复杂的报表，操作简单易用。针对软件开发商和系统集成商，用于快速构建企业信息系统的中国式Web报表软件。</div></pre></td></tr></table></figure><h3 id="帆软报表优势"><a href="#帆软报表优势" class="headerlink" title="帆软报表优势"></a>帆软报表优势</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1. 使用FineReport可以快速灵活地制作报表，搭建统一的数据决策和管理平台，让更多的数据用于业务经营和决策。</div><div class="line">2. 使用FineReport可以快速开发报表，无缝集成到各类系统中，加快项目进度的同时，也能保证报表系统的拓展性和可维护性。</div></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="/img/fr.png" alt="image"></p><p><img src="/img/fr2.gif" alt="image"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">本人已成为帆软报表认证工程师，后续将陆续推出帆软报表相关知识。</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;工具：&quot;&gt;&lt;a href=&quot;#工具：&quot; class=&quot;headerlink&quot; title=&quot;工具：&quot;&gt;&lt;/a&gt;工具：&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1.finereport8.0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2.java&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3.mysql&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="帆软报表" scheme="http://yoursite.com/tags/%E5%B8%86%E8%BD%AF%E6%8A%A5%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法</title>
    <link href="http://yoursite.com/2017/08/05/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95--%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    <id>http://yoursite.com/2017/08/05/常见排序算法--持续更新中/</id>
    <published>2017-08-05T15:11:01.000Z</published>
    <updated>2018-01-16T07:45:15.235Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="前篇"><a href="#前篇" class="headerlink" title="前篇"></a>前篇</h3><p>本文章主要涵盖了：</p><p>O(n^2)的：选择排序、插入排序、冒泡排序</p><p>O(n*logn)的：快速排序、希尔排序、归并排序、堆排序<br><a id="more"></a><br>以及三种线性排序：计数排序、基数排序、桶排序（严格来说这只是一种排序思想，计数属于桶排的一种）</p><h3 id="排序测试类"><a href="#排序测试类" class="headerlink" title="排序测试类"></a>排序测试类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">package mysort;</div><div class="line"></div><div class="line">import java.util.Arrays;</div><div class="line"></div><div class="line">public class SortTest &#123;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">// 测试数组</div><div class="line">int[] arr = &#123; 4, 2, 1, 3, 5, 7, 6, 8, 10, 9 &#125;;</div><div class="line">// 排序前</div><div class="line">System.out.println(&quot;排序前：&quot; + Arrays.toString(arr));</div><div class="line"></div><div class="line">// 排序算法</div><div class="line">// 1.冒泡排序从前往后排</div><div class="line">// BubbleSort1.bubbleSort(arr);</div><div class="line">// 2.冒泡排序，从后往前排</div><div class="line">// BubbleSort2.bubbleSort(arr);</div><div class="line">// 3.选择排序</div><div class="line">//SelectionSort.selectionSort(arr);</div><div class="line">//4.插入排序</div><div class="line">InsertSort.insertSort(arr);</div><div class="line"></div><div class="line">// 排序后</div><div class="line">System.out.println(&quot;排序后：&quot; + Arrays.toString(arr));</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line"> * 交换数组两元素方法</div><div class="line"> */</div><div class="line">public static void swap(int[] arr, int i, int j) &#123;</div><div class="line">int temp = arr[i];</div><div class="line">arr[i] = arr[j];</div><div class="line">arr[j] = temp;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="1-从前往后冒"><a href="#1-从前往后冒" class="headerlink" title="1.从前往后冒"></a>1.从前往后冒</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">package mysort;</div><div class="line">/**</div><div class="line"> * 冒泡排序:从前往后冒</div><div class="line"> * 先从第一个元素开始，两两元素对比，位置不对就交换元素，比如arr[0]&gt;arr[1]，就交换,</div><div class="line"> * 交换后arr[1]再和arr[2]对比，每一轮对比完，冒泡出最大的元素，最大的元素不参与下一轮对比。</div><div class="line"> * 一共有arr.length-1轮对比</div><div class="line"> * @author ysl</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class BubbleSort1 &#123;</div><div class="line">public static void bubbleSort(int[] arr)&#123;</div><div class="line">int n = arr.length-1;</div><div class="line">for(int i=0;i&lt;n;i++)&#123;//一共有arr.length-1轮对比</div><div class="line">for(int j=0;j&lt;n-i;j++)&#123;//每一轮要对比 arr.length-1-i次</div><div class="line">if(arr[j]&gt;arr[j+1])&#123;</div><div class="line">SortTest.swap(arr, j, j+1);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-从后往前冒"><a href="#2-从后往前冒" class="headerlink" title="2.从后往前冒"></a>2.从后往前冒</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">package mysort;</div><div class="line">/**</div><div class="line"> * 冒泡排序:从后往前冒</div><div class="line"> * 先从最后一个元素开始，两两比较，位置不对就交换元素，比如arr[4]&gt;arr[5],</div><div class="line"> * 交换后arr[5]在4的位置，再和后续元素对比，每一轮对比完，冒泡出最小的元素在最前面，最小元素不参与下一轮对比。</div><div class="line"> * 一共有arr.length-1轮对比</div><div class="line"> * @author ysl</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class BubbleSort2 &#123;</div><div class="line">public static void bubbleSort(int[] arr)&#123;</div><div class="line">int n = arr.length-1;</div><div class="line">for(int i=0;i&lt;n;i++)&#123;//一共有arr.length-1轮对比</div><div class="line">for(int j=n;j&gt;i;j--)&#123;</div><div class="line">if(arr[j]&lt;arr[j-1])&#123;</div><div class="line">SortTest.swap(arr, j, j-1);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package mysort;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 先从0-n-1里面选一个最小的，然后和第0位交换顺序； 从1-n-1里面选一个最小的，然后和第1位交换顺序； 以此类推.. </div><div class="line"> * 直到 arr.length-2 - arr.length-1对比</div><div class="line"> * </div><div class="line"> * @author ysl</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class SelectionSort &#123;</div><div class="line">public static void selectionSort(int[] arr) &#123;</div><div class="line">int n = arr.length - 1;</div><div class="line">for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">for (int j = i + 1; j &lt; n + 1; j++) &#123;</div><div class="line">if (arr[i] &gt; arr[j]) &#123;</div><div class="line">SortTest.swap(arr, i, j);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package mysort;</div><div class="line">/*</div><div class="line"> * 插入排序基本思想</div><div class="line"> * 就和平常和朋友玩斗地主时抓牌一样。</div><div class="line"> * 每次抽一张牌，然后按序插入到手上已有的牌里面。</div><div class="line"> * 直到所有的牌抽完，然后就结束了。</div><div class="line"> * 将n个元素的数列分为已有序和无序两个部分，如插入排序过程示例下所示： 　　</div><div class="line"> * &#123;&#123;a1&#125;，&#123;a2，a3，a4，…，an&#125;&#125; 　　</div><div class="line"> * &#123;&#123;a1⑴，a2⑴&#125;，&#123;a3⑴，a4⑴ …，an⑴&#125;&#125; 　</div><div class="line"> * &#123;&#123;a1(n-1），a2(n-1) ，…&#125;,&#123;an(n-1)&#125;&#125; 　　</div><div class="line"> * 每次处理就是将无序数列的第一个元素与有序数列的元素从后往前逐个进行比较，</div><div class="line"> * 找出插入位置，将该元素插入到有序数列的合适位置中。</div><div class="line"> */</div><div class="line">public class InsertSort &#123;</div><div class="line">public static void insertSort(int[] arr)&#123;</div><div class="line">int n = arr.length-1;</div><div class="line">for(int i=1;i&lt;=n;i++)&#123;//从索引1开始和前面索引0对比，最后一个对比的索引n和前面n-1个对比</div><div class="line">for(int j=i;(j&gt;0)&amp;&amp;(arr[j]&lt;arr[j-1]);j--)&#123;</div><div class="line">SortTest.swap(arr, j, j-1);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前篇&quot;&gt;&lt;a href=&quot;#前篇&quot; class=&quot;headerlink&quot; title=&quot;前篇&quot;&gt;&lt;/a&gt;前篇&lt;/h3&gt;&lt;p&gt;本文章主要涵盖了：&lt;/p&gt;
&lt;p&gt;O(n^2)的：选择排序、插入排序、冒泡排序&lt;/p&gt;
&lt;p&gt;O(n*logn)的：快速排序、希尔排序、归并排序、堆排序&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>点击查询按钮，留在当前tab页</title>
    <link href="http://yoursite.com/2017/08/02/%E7%82%B9%E5%87%BB%E6%9F%A5%E8%AF%A2%E6%8C%89%E9%92%AE%EF%BC%8C%E7%95%99%E5%9C%A8%E5%BD%93%E5%89%8Dtab%E9%A1%B5/"/>
    <id>http://yoursite.com/2017/08/02/点击查询按钮，留在当前tab页/</id>
    <published>2017-08-02T15:12:01.000Z</published>
    <updated>2018-01-18T04:29:38.117Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>当frm有几个tab页，每次点击查询按钮，都会自动返回至第一个tab页。点击完查询按钮，留在当前tab页，改善报表体验。</p><h3 id="具体js"><a href="#具体js" class="headerlink" title="具体js"></a>具体js</h3><p>1.首先在tabpane0添加tab切换事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout(function()&#123;</div><div class="line">        window.CardIndex=_g().getWidgetByName(&quot;tabpane0&quot;).getShowIndex();//记录当前的tab页索引</div><div class="line">&#125;,10);</div></pre></td></tr></table></figure><p>2.在tabpane0设置初始化事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var aa = window.CardIndex;</div><div class="line">setTimeout(function()&#123;</div><div class="line">        _g().getWidgetByName(&quot;tabpane0&quot;).showCardByIndex(aa);</div><div class="line">        &#125;,2500);</div></pre></td></tr></table></figure><p>由于帆软默认是加载后返回第一个tab页，因加载数据，刷新页面时间影响，有可能返回当前tab时，可能看不到页面，再次切换回来才能看的到。<br>这时候就需要调整返回当前tab的时间，如上2500毫秒，可自行实验测试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h3&gt;&lt;p&gt;当f
      
    
    </summary>
    
    
      <category term="帆软报表" scheme="http://yoursite.com/tags/%E5%B8%86%E8%BD%AF%E6%8A%A5%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>linux系统配置jdk环境变量</title>
    <link href="http://yoursite.com/2017/05/05/linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AEjdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2017/05/05/linux系统配置jdk环境变量/</id>
    <published>2017-05-05T08:34:23.000Z</published>
    <updated>2018-01-11T09:08:32.623Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="1-编辑好环境变量"><a href="#1-编辑好环境变量" class="headerlink" title="1.编辑好环境变量"></a>1.编辑好环境变量</h3><hr><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">JAVA_HOME=/usr/java/jdk1.8.0_11  </div><div class="line">==//注意：根据自己jdk所在位置==</div><div class="line"></div><div class="line">PATH=$JAVA_HOME/bin:$PATH</div><div class="line"></div><div class="line">CLASSPATH=$JAVA_HOME/jre/lib/ext:$JAVA_HOME/lib/tools.jar</div><div class="line"></div><div class="line">export PATH JAVA_HOME CLASSPATH</div></pre></td></tr></table></figure><hr><h3 id="2-编辑profile文件"><a href="#2-编辑profile文件" class="headerlink" title="2.编辑profile文件"></a>2.编辑profile文件</h3><p>[haha@localhost ~]$ vi /etc/profile</p><p>打开文件后，按  i，在空白处插入编辑好的环境变量，如下图：<br><img src="/img/hj.png" alt="image"></p><p>按 ‘shift’ + ‘:’</p><p>输入 wq 按回车保存并退出</p><h3 id="3-再输入命定source-etc-profile"><a href="#3-再输入命定source-etc-profile" class="headerlink" title="3.再输入命定source /etc/profile"></a>3.再输入命定source /etc/profile</h3><h3 id="4-再输入javac命定就可以测试是否配置好啦"><a href="#4-再输入javac命定就可以测试是否配置好啦" class="headerlink" title="4.再输入javac命定就可以测试是否配置好啦"></a>4.再输入javac命定就可以测试是否配置好啦</h3><p> 祝你好运！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-编辑好环境变量&quot;&gt;&lt;a href=&quot;#1-编辑好环境变量&quot; class=&quot;headerlink&quot; title=&quot;1.编辑好环境变量&quot;&gt;&lt;/a&gt;1.编辑好环境变量&lt;/h3&gt;&lt;hr&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>mysql实现环比</title>
    <link href="http://yoursite.com/2017/04/11/mysql%E5%AE%9E%E7%8E%B0%E7%8E%AF%E6%AF%94/"/>
    <id>http://yoursite.com/2017/04/11/mysql实现环比/</id>
    <published>2017-04-11T14:33:41.000Z</published>
    <updated>2018-01-17T08:02:52.754Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="环比概念："><a href="#环比概念：" class="headerlink" title="环比概念："></a>环比概念：</h3><p>(本期-上期)/上期 * 100%<br><a id="more"></a></p><h3 id="模拟数据："><a href="#模拟数据：" class="headerlink" title="模拟数据："></a>模拟数据：</h3><p>假设某银行每季度贷款(亿)情况如下：</p><p>表：loan</p><table><thead><tr><th>data_dt</th><th>amt</th></tr></thead><tbody><tr><td>201603</td><td>1800</td></tr><tr><td>201606</td><td>2000</td></tr><tr><td>201609</td><td>1900</td></tr><tr><td>201612</td><td>2200</td></tr><tr><td>201703</td><td>2300</td></tr><tr><td>201706</td><td>2400</td></tr></tbody></table><p>要现实</p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>要实现环比，把本期数据减去上期数据，在此要做自连接，假设:</p><p>上期数据表1： loan as a</p><p>本期数据表2： loan as b</p><p>关联条件:b的data_dt等于a的data_dt加3个月</p><h3 id="具体sql"><a href="#具体sql" class="headerlink" title="具体sql"></a>具体sql</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">b.data_dt,</div><div class="line">case substr(b.data_dt,5,2)</div><div class="line">when &apos;03&apos; then concat(substr(b.data_dt,1,4),&apos;Q1&apos;) </div><div class="line">when &apos;06&apos; then concat(substr(b.data_dt,1,4),&apos;Q2&apos;) </div><div class="line">when &apos;09&apos; then concat(substr(b.data_dt,1,4),&apos;Q3&apos;) </div><div class="line">when &apos;12&apos; then concat(substr(b.data_dt,1,4),&apos;Q4&apos;) </div><div class="line">end dt,</div><div class="line">(b.amt-a.amt)/a.amt 环比</div><div class="line">FROM</div><div class="line">loan a JOIN</div><div class="line">loan b</div><div class="line">ON b.data_dt=PERIOD_ADD(a.data_dt,3)</div></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><table><thead><tr><th>dt</th><th>环比</th></tr></thead><tbody><tr><td>2016Q2</td><td>0.1111</td></tr><tr><td>2016Q3</td><td>-0.0500</td></tr><tr><td>2016Q4</td><td>0.1579</td></tr><tr><td>2017Q1</td><td>0.0455</td></tr><tr><td>2017Q2</td><td>0.0435</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;环比概念：&quot;&gt;&lt;a href=&quot;#环比概念：&quot; class=&quot;headerlink&quot; title=&quot;环比概念：&quot;&gt;&lt;/a&gt;环比概念：&lt;/h3&gt;&lt;p&gt;(本期-上期)/上期 * 100%&lt;br&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>java模拟电子表，打印火柴类型时间</title>
    <link href="http://yoursite.com/2017/01/15/java%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E8%A1%A8%EF%BC%8C%E6%89%93%E5%8D%B0%E7%81%AB%E6%9F%B4%E7%B1%BB%E5%9E%8B%E6%97%B6%E9%97%B4/"/>
    <id>http://yoursite.com/2017/01/15/java模拟电子表，打印火柴类型时间/</id>
    <published>2017-01-15T08:44:14.000Z</published>
    <updated>2018-01-11T08:25:45.012Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="直接上代码！就是这么刚！"><a href="#直接上代码！就是这么刚！" class="headerlink" title="直接上代码！就是这么刚！"></a>直接上代码！就是这么刚！</h3><a id="more"></a><pre><code>public static void main(String[] args) {   //通过Timer()实现定时1秒任务   // Timer timer = new Timer();    // timer.schedule(new TimerTask() {    // @Override    // public void run() {    // Calendar calendar = Calendar.getInstance();    // Date date = calendar.getTime();    // printTime(date);    // }    // },1000,1000);//线程sleep(1000)控制时间，实现定时new Thread(new Runnable() {    @Override    public void run() {        while(true){            Calendar calendar = Calendar.getInstance();            Date date = calendar.getTime();            printTime(date);            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}).start();}//打印时间方法public static void printTime(Date date){        SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss&quot;);    String time = sdf.format(date);    System.out.println(time);//inputIntList存放每个数字代表的轨迹组合int[]    List&lt;int[]&gt; inputIntList = new LinkedList&lt;int[]&gt;();    for(int i=0;i&lt;time.length();i++){    String a =String.valueOf(time.charAt(i));    //将数字转化为相应的轨迹组合int[]，并加到inputIntList中    if(!a.equals(&quot;:&quot;)){        inputIntList.add(matchNumberGenerator(a));      }}//遍历inputIntList，打印数字    Iterator&lt;int[]&gt; iterator = null;//5行，3列打印    for(int i = 0; i &lt; 5; i++){    iterator = inputIntList.iterator();    while(iterator.hasNext()){        printNumber(iterator.next(),i*3,(i+1)*3;    }    System.out.println();    }   }</code></pre><!--more--><pre><code>//将数字转化为相应的轨迹组合int[]public static int[] matchNumberGenerator(String a){int result[] = null;switch(a){//&quot;_&quot;--&gt;2 &quot; &quot;--&gt;0 &quot;|&quot;--&gt;1case &quot;0&quot;:    result = new int[]{0,2,0,1,0,1,1,0,1,1,0,1,1,2,1};    //&quot;&apos; _ &apos;| |&apos;| |&apos;| |&apos;|_|&quot;.split(&quot;,&quot;);    break;case &quot;1&quot;:    result = new int[]{0,0,0,0,0,1,0,0,1,0,0,1,0,0,1};    //&quot;&apos;   &apos;  |&apos;  |&apos;  |&apos;  |&quot;.split(&quot;,&quot;);    break;case &quot;2&quot;:    result = new int[]{0,2,0,0,0,1,0,2,1,1,0,0,1,2,0};    //&quot;&apos; _ &apos;  |&apos; _|&apos;|  &apos;|_ &quot;.split(&quot;,&quot;);    break;case &quot;3&quot;:    result = new int[]{0,2,0,0,0,1,0,2,1,0,0,1,0,2,1};    //&quot;&apos; _ &apos;  |&apos; _|&apos;  |&apos; _|&quot;.split(&quot;,&quot;);    break;case &quot;4&quot;:    result = new int[]{0,0,0,1,0,1,1,2,1,0,0,1,0,0,1};    //&quot;&apos;   &apos;| |&apos;|_|&apos;  |&apos;  |&quot;.split(&quot;,&quot;);    break;case &quot;5&quot;:    result = new int[]{0,2,0,1,0,0,1,2,0,0,0,1,0,2,1};    //&quot;&apos; _ &apos;|  &apos;|_ &apos;  |&apos; _|&quot;.split(&quot;,&quot;);    break;case &quot;6&quot;:    result = new int[]{0,2,0,1,0,0,1,2,0,1,0,1,1,2,1};    //&quot;&apos; _ &apos;|  &apos;|_ &apos;| |&apos;|_|&quot;.split(&quot;,&quot;);    break;case &quot;7&quot;:    result = new int[]{0,2,0,0,0,1,0,0,1,0,0,1,0,0,1};    //&quot;&apos; _ &apos;  |&apos;  |&apos;  |&apos;  |&quot;.split(&quot;,&quot;);    break;case &quot;8&quot;:    result = new int[]{0,2,0,1,0,1,1,2,1,1,0,1,1,2,1};    //&quot;&apos; _ &apos;| |&apos;|_|&apos;| |&apos;|_|&quot;.split(&quot;,&quot;);    break;case &quot;9&quot;:    result = new int[]{0,2,0,1,0,1,1,2,1,0,0,1,0,2,1};    //&quot;&apos; _ &apos;| |&apos;|_|&apos;  |&apos; _|&quot;.split(&quot;,&quot;);    break;}return result;}</code></pre><!--more--><pre><code> //根据轨迹组合，打印相应数字public static void printNumber(int[] numberArray, int arrayIndex, int arrayIndexEnd){for(int i = arrayIndex; i &lt; arrayIndexEnd;i++){    switch(numberArray[i]){    //     &quot;_&quot;--&gt;2     &quot; &quot;--&gt;0      &quot;|&quot;--&gt;1    case 0:        System.out.print(&quot; &quot;);        break;    case 1:        System.out.print(&quot;|&quot;);        break;    case 2:        System.out.print(&quot;_&quot;);        break;    }}System.out.print(&quot; &quot;); }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;直接上代码！就是这么刚！&quot;&gt;&lt;a href=&quot;#直接上代码！就是这么刚！&quot; class=&quot;headerlink&quot; title=&quot;直接上代码！就是这么刚！&quot;&gt;&lt;/a&gt;直接上代码！就是这么刚！&lt;/h3&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>雪花</title>
    <link href="http://yoursite.com/2016/12/02/%E9%9B%AA%E8%8A%B1/"/>
    <id>http://yoursite.com/2016/12/02/雪花/</id>
    <published>2016-12-02T11:30:40.000Z</published>
    <updated>2018-01-11T08:30:53.625Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="雪花"><a href="#雪花" class="headerlink" title="雪花"></a>雪花</h3><a id="more"></a><p>愿化为一朵雪花</p><p>在天空盘旋，盘旋</p><p>我没了方向</p><p>依然在那棵掉了叶的老树旁</p><p>等你</p><p>我可爱的姑娘</p><p>没错</p><p>你是在眺望</p><p>可那清澈的眼眸没有我的方向</p><p>飘过你的长发</p><p>让我再闻一闻你的芬芳</p><p>幻想沾住你的衣裳</p><p>永远永远消溶在那温柔的心扉</p><p>可我只能在你身边护航</p><p>等到那温暖太阳的出现</p><p>于是</p><p>断了我的宿命</p><p>淡了你的温柔</p><p>我在笑</p><p>我在溶化</p><p>默默的陪着你到我生命的尽头</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;雪花&quot;&gt;&lt;a href=&quot;#雪花&quot; class=&quot;headerlink&quot; title=&quot;雪花&quot;&gt;&lt;/a&gt;雪花&lt;/h3&gt;
    
    </summary>
    
    
      <category term="诗和远方" scheme="http://yoursite.com/tags/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9/"/>
    
  </entry>
  
  <entry>
    <title>青春</title>
    <link href="http://yoursite.com/2016/08/03/%E9%9D%92%E6%98%A5/"/>
    <id>http://yoursite.com/2016/08/03/青春/</id>
    <published>2016-08-03T12:12:11.000Z</published>
    <updated>2018-01-11T08:30:19.007Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="青春"><a href="#青春" class="headerlink" title="青春"></a>青春</h3><a id="more"></a><p>看不清</p><p>路的尽头</p><p>是围巾拉扯着行李箱</p><p>月光抛给我一个眼神</p><p>焖熟了的思念</p><p>也合着脚印</p><p>拼了命的奔跑</p><p>去拥抱</p><p>慢慢模糊的脸庞</p><p>骤来的雨</p><p>触碰了玻璃的心房</p><p>也打翻了发香</p><p>里面有湿润的眼眶</p><p>和跳舞的衣裳</p><p>我不允许</p><p>它褪去颜色 </p><p>路在尽头</p><p>依偎着暗黄的灯光</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;青春&quot;&gt;&lt;a href=&quot;#青春&quot; class=&quot;headerlink&quot; title=&quot;青春&quot;&gt;&lt;/a&gt;青春&lt;/h3&gt;
    
    </summary>
    
    
      <category term="诗和远方" scheme="http://yoursite.com/tags/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9/"/>
    
  </entry>
  
  <entry>
    <title>一个人一首歌</title>
    <link href="http://yoursite.com/2015/07/05/%E4%B8%80%E4%B8%AA%E4%BA%BA%E4%B8%80%E9%A6%96%E6%AD%8C%20/"/>
    <id>http://yoursite.com/2015/07/05/一个人一首歌 /</id>
    <published>2015-07-05T15:13:05.000Z</published>
    <updated>2018-01-17T07:00:07.323Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="一个人一首歌"><a href="#一个人一首歌" class="headerlink" title="一个人一首歌"></a>一个人一首歌</h3><a id="more"></a><p><img src="/img/tg.jpg" alt="image"></p><p>一首歌</p><p>听了千万遍</p><p>不经意才想起</p><p>环绕的</p><p>是你的身影</p><p>因为一个人而喜欢一首歌</p><p>淡淡的忘了自己</p><p>或许你不会再听起</p><p>也不会有我的参与</p><p>留下一个人的回忆</p><p>扎根在一个人的梦里</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一个人一首歌&quot;&gt;&lt;a href=&quot;#一个人一首歌&quot; class=&quot;headerlink&quot; title=&quot;一个人一首歌&quot;&gt;&lt;/a&gt;一个人一首歌&lt;/h3&gt;
    
    </summary>
    
    
      <category term="诗和远方" scheme="http://yoursite.com/tags/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9/"/>
    
  </entry>
  
  <entry>
    <title>时间</title>
    <link href="http://yoursite.com/2015/03/05/%E6%97%B6%E9%97%B4/"/>
    <id>http://yoursite.com/2015/03/05/时间/</id>
    <published>2015-03-05T02:11:05.000Z</published>
    <updated>2018-01-17T08:32:51.278Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p> 时间只是暂时尘封你的记忆</p><p> 还以为你已忘却</p><p> 可当再次相遇时</p><p> 它又会将你的心一片片拨开</p><p> 一切又是那么清晰</p><p> 无法抵挡那股气息</p><p> 原来你真的没忘记</p><p> 于是开始不相信时间了 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;时间&quot;&gt;&lt;a href=&quot;#时间&quot; class=&quot;headerlink&quot; title=&quot;时间&quot;&gt;&lt;/a&gt;时间&lt;/h3&gt;&lt;p&gt; 时
      
    
    </summary>
    
    
      <category term="诗和远方" scheme="http://yoursite.com/tags/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9/"/>
    
  </entry>
  
  <entry>
    <title>月光</title>
    <link href="http://yoursite.com/2014/02/01/%E6%9C%88%E5%85%89/"/>
    <id>http://yoursite.com/2014/02/01/月光/</id>
    <published>2014-02-01T01:30:00.000Z</published>
    <updated>2018-01-17T08:28:25.871Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="月光"><a href="#月光" class="headerlink" title="月光"></a>月光</h3><a id="more"></a><p>无端闯入的衣裳</p><p>带走了我的方向</p><p>那冰冷的双眸</p><p>有风吹过的温柔</p><p>使劲劈下去</p><p>划破苍穹</p><p>娇小的身躯在泪水中倒下</p><p>一刀两断  </p><p>一半藏着我的思念   </p><p>一半封着我的坚持                                 </p><p>抱起月光 </p><p>埋葬在心中    </p><p>散落于天涯  </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;月光&quot;&gt;&lt;a href=&quot;#月光&quot; class=&quot;headerlink&quot; title=&quot;月光&quot;&gt;&lt;/a&gt;月光&lt;/h3&gt;
    
    </summary>
    
    
      <category term="诗和远方" scheme="http://yoursite.com/tags/%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9/"/>
    
  </entry>
  
</feed>
